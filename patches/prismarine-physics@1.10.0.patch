diff --git a/index.js b/index.js
index d7b8db58f5e207553dbf88a7cb2c38c60acbdfa9..6f9661827f1a45ca87876615520e570c8ecef259 100644
--- a/index.js
+++ b/index.js
@@ -206,22 +206,37 @@ function Physics (mcData, world) {
     const surroundingBBs = getSurroundingBBs(world, queryBB)
     const oldBB = playerBB.clone()
 
+    // Dynamic axis order matching Java 1.21.6 Entity.collide()
+    const resolveZFirst = Math.abs(dx) < Math.abs(dz)
+
     for (const blockBB of surroundingBBs) {
       dy = blockBB.computeOffsetY(playerBB, dy)
     }
     playerBB.offset(0, dy, 0)
 
-    for (const blockBB of surroundingBBs) {
-      dx = blockBB.computeOffsetX(playerBB, dx)
-    }
-    playerBB.offset(dx, 0, 0)
+    if (resolveZFirst) {
+      for (const blockBB of surroundingBBs) {
+        dz = blockBB.computeOffsetZ(playerBB, dz)
+      }
+      playerBB.offset(0, 0, dz)
 
-    for (const blockBB of surroundingBBs) {
-      dz = blockBB.computeOffsetZ(playerBB, dz)
+      for (const blockBB of surroundingBBs) {
+        dx = blockBB.computeOffsetX(playerBB, dx)
+      }
+      playerBB.offset(dx, 0, 0)
+    } else {
+      for (const blockBB of surroundingBBs) {
+        dx = blockBB.computeOffsetX(playerBB, dx)
+      }
+      playerBB.offset(dx, 0, 0)
+
+      for (const blockBB of surroundingBBs) {
+        dz = blockBB.computeOffsetZ(playerBB, dz)
+      }
+      playerBB.offset(0, 0, dz)
     }
-    playerBB.offset(0, 0, dz)
 
-    // Step on block if height < stepHeight
+    // Step on block if height < stepHeight (candidate-height algorithm matching Java 1.21.6)
     if (physics.stepHeight > 0 &&
       (entity.onGround || (dy !== oldVelY && oldVelY < 0)) &&
       (dx !== oldVelX || dz !== oldVelZ)) {
@@ -230,66 +245,149 @@ function Physics (mcData, world) {
       const oldVelZCol = dz
       const oldBBCol = playerBB.clone()
 
-      dy = physics.stepHeight
-      const queryBB = oldBB.clone().extend(oldVelX, dy, oldVelZ)
-      const surroundingBBs = getSurroundingBBs(world, queryBB)
+      // Collect candidate step heights from nearby block tops
+      const stepQueryBB = oldBB.clone().extend(oldVelX, physics.stepHeight, oldVelZ)
+      const stepSurroundingBBs = getSurroundingBBs(world, stepQueryBB)
 
-      const BB1 = oldBB.clone()
-      const BB2 = oldBB.clone()
-      const BB_XZ = BB1.clone().extend(dx, 0, dz)
-
-      let dy1 = dy
-      let dy2 = dy
-      for (const blockBB of surroundingBBs) {
-        dy1 = blockBB.computeOffsetY(BB_XZ, dy1)
-        dy2 = blockBB.computeOffsetY(BB2, dy2)
+      const candidates = new Set()
+      for (const blockBB of stepSurroundingBBs) {
+        const candidateY = blockBB.maxY - oldBB.minY
+        if (candidateY > 0 && candidateY <= physics.stepHeight) {
+          candidates.add(candidateY)
+        }
       }
-      BB1.offset(0, dy1, 0)
-      BB2.offset(0, dy2, 0)
 
-      let dx1 = oldVelX
-      let dx2 = oldVelX
-      for (const blockBB of surroundingBBs) {
-        dx1 = blockBB.computeOffsetX(BB1, dx1)
-        dx2 = blockBB.computeOffsetX(BB2, dx2)
-      }
-      BB1.offset(dx1, 0, 0)
-      BB2.offset(dx2, 0, 0)
+      // Sort candidates ascending (try smallest step first)
+      const sortedCandidates = Array.from(candidates).sort((a, b) => a - b)
+
+      let bestDx = oldVelXCol
+      let bestDy = oldVelYCol
+      let bestDz = oldVelZCol
+      let bestBB = oldBBCol
+      let bestHorizDist = oldVelXCol * oldVelXCol + oldVelZCol * oldVelZCol
+      let found = false
+
+      for (const candidateStep of sortedCandidates) {
+        let stepBB = oldBB.clone()
+        let sDy = candidateStep
+        let sDx = oldVelX
+        let sDz = oldVelZ
+
+        // Move up by candidate height
+        for (const blockBB of stepSurroundingBBs) {
+          sDy = blockBB.computeOffsetY(stepBB, sDy)
+        }
+        stepBB.offset(0, sDy, 0)
 
-      let dz1 = oldVelZ
-      let dz2 = oldVelZ
-      for (const blockBB of surroundingBBs) {
-        dz1 = blockBB.computeOffsetZ(BB1, dz1)
-        dz2 = blockBB.computeOffsetZ(BB2, dz2)
+        // Resolve horizontal with dynamic axis order
+        const stepResolveZFirst = Math.abs(oldVelX) < Math.abs(oldVelZ)
+        if (stepResolveZFirst) {
+          for (const blockBB of stepSurroundingBBs) {
+            sDz = blockBB.computeOffsetZ(stepBB, sDz)
+          }
+          stepBB.offset(0, 0, sDz)
+          for (const blockBB of stepSurroundingBBs) {
+            sDx = blockBB.computeOffsetX(stepBB, sDx)
+          }
+          stepBB.offset(sDx, 0, 0)
+        } else {
+          for (const blockBB of stepSurroundingBBs) {
+            sDx = blockBB.computeOffsetX(stepBB, sDx)
+          }
+          stepBB.offset(sDx, 0, 0)
+          for (const blockBB of stepSurroundingBBs) {
+            sDz = blockBB.computeOffsetZ(stepBB, sDz)
+          }
+          stepBB.offset(0, 0, sDz)
+        }
+
+        // Settle back down
+        let settleY = -candidateStep
+        for (const blockBB of stepSurroundingBBs) {
+          settleY = blockBB.computeOffsetY(stepBB, settleY)
+        }
+        stepBB.offset(0, settleY, 0)
+
+        const horizDist = sDx * sDx + sDz * sDz
+        if (horizDist > bestHorizDist) {
+          bestDx = sDx
+          bestDy = sDy + settleY
+          bestDz = sDz
+          bestBB = stepBB
+          bestHorizDist = horizDist
+          found = true
+          break // First improvement wins (smallest step that helps)
+        }
       }
-      BB1.offset(0, 0, dz1)
-      BB2.offset(0, 0, dz2)
 
-      const norm1 = dx1 * dx1 + dz1 * dz1
-      const norm2 = dx2 * dx2 + dz2 * dz2
+      if (!found) {
+        // Fallback: original dual-path approach
+        dy = physics.stepHeight
+        const queryBB = oldBB.clone().extend(oldVelX, dy, oldVelZ)
+        const surroundingBBs = getSurroundingBBs(world, queryBB)
+
+        const BB1 = oldBB.clone()
+        const BB2 = oldBB.clone()
+        const BB_XZ = BB1.clone().extend(dx, 0, dz)
+
+        let dy1 = dy
+        let dy2 = dy
+        for (const blockBB of surroundingBBs) {
+          dy1 = blockBB.computeOffsetY(BB_XZ, dy1)
+          dy2 = blockBB.computeOffsetY(BB2, dy2)
+        }
+        BB1.offset(0, dy1, 0)
+        BB2.offset(0, dy2, 0)
+
+        let dx1 = oldVelX
+        let dx2 = oldVelX
+        for (const blockBB of surroundingBBs) {
+          dx1 = blockBB.computeOffsetX(BB1, dx1)
+          dx2 = blockBB.computeOffsetX(BB2, dx2)
+        }
+        BB1.offset(dx1, 0, 0)
+        BB2.offset(dx2, 0, 0)
+
+        let dz1 = oldVelZ
+        let dz2 = oldVelZ
+        for (const blockBB of surroundingBBs) {
+          dz1 = blockBB.computeOffsetZ(BB1, dz1)
+          dz2 = blockBB.computeOffsetZ(BB2, dz2)
+        }
+        BB1.offset(0, 0, dz1)
+        BB2.offset(0, 0, dz2)
 
-      if (norm1 > norm2) {
-        dx = dx1
-        dy = -dy1
-        dz = dz1
-        playerBB = BB1
-      } else {
-        dx = dx2
-        dy = -dy2
-        dz = dz2
-        playerBB = BB2
-      }
+        const norm1 = dx1 * dx1 + dz1 * dz1
+        const norm2 = dx2 * dx2 + dz2 * dz2
 
-      for (const blockBB of surroundingBBs) {
-        dy = blockBB.computeOffsetY(playerBB, dy)
-      }
-      playerBB.offset(0, dy, 0)
+        if (norm1 > norm2) {
+          dx = dx1
+          dy = -dy1
+          dz = dz1
+          playerBB = BB1
+        } else {
+          dx = dx2
+          dy = -dy2
+          dz = dz2
+          playerBB = BB2
+        }
+
+        for (const blockBB of surroundingBBs) {
+          dy = blockBB.computeOffsetY(playerBB, dy)
+        }
+        playerBB.offset(0, dy, 0)
 
-      if (oldVelXCol * oldVelXCol + oldVelZCol * oldVelZCol >= dx * dx + dz * dz) {
-        dx = oldVelXCol
-        dy = oldVelYCol
-        dz = oldVelZCol
-        playerBB = oldBBCol
+        if (oldVelXCol * oldVelXCol + oldVelZCol * oldVelZCol >= dx * dx + dz * dz) {
+          dx = oldVelXCol
+          dy = oldVelYCol
+          dz = oldVelZCol
+          playerBB = oldBBCol
+        }
+      } else {
+        dx = bestDx
+        dy = bestDy
+        dz = bestDz
+        playerBB = bestBB
       }
     }
 
diff --git a/lib/aabb.js b/lib/aabb.js
index 6b78f46bea6ff10de81749809d1b58a0ab8f2868..95b73d8f6348eaf94f8bb14012309b66b1cc6e6e 100644
--- a/lib/aabb.js
+++ b/lib/aabb.js
@@ -1,3 +1,5 @@
+const EPSILON = 1.0e-7
+
 class AABB {
   constructor (x0, y0, z0, x1, y1, z1) {
     this.minX = x0
@@ -65,10 +67,10 @@ class AABB {
   }
 
   computeOffsetX (other, offsetX) {
-    if (other.maxY > this.minY && other.minY < this.maxY && other.maxZ > this.minZ && other.minZ < this.maxZ) {
-      if (offsetX > 0.0 && other.maxX <= this.minX) {
+    if (other.maxY - this.minY > EPSILON && this.maxY - other.minY > EPSILON && other.maxZ - this.minZ > EPSILON && this.maxZ - other.minZ > EPSILON) {
+      if (offsetX > 0.0 && other.maxX <= this.minX + EPSILON) {
         offsetX = Math.min(this.minX - other.maxX, offsetX)
-      } else if (offsetX < 0.0 && other.minX >= this.maxX) {
+      } else if (offsetX < 0.0 && other.minX >= this.maxX - EPSILON) {
         offsetX = Math.max(this.maxX - other.minX, offsetX)
       }
     }
@@ -76,10 +78,10 @@ class AABB {
   }
 
   computeOffsetY (other, offsetY) {
-    if (other.maxX > this.minX && other.minX < this.maxX && other.maxZ > this.minZ && other.minZ < this.maxZ) {
-      if (offsetY > 0.0 && other.maxY <= this.minY) {
+    if (other.maxX - this.minX > EPSILON && this.maxX - other.minX > EPSILON && other.maxZ - this.minZ > EPSILON && this.maxZ - other.minZ > EPSILON) {
+      if (offsetY > 0.0 && other.maxY <= this.minY + EPSILON) {
         offsetY = Math.min(this.minY - other.maxY, offsetY)
-      } else if (offsetY < 0.0 && other.minY >= this.maxY) {
+      } else if (offsetY < 0.0 && other.minY >= this.maxY - EPSILON) {
         offsetY = Math.max(this.maxY - other.minY, offsetY)
       }
     }
@@ -87,10 +89,10 @@ class AABB {
   }
 
   computeOffsetZ (other, offsetZ) {
-    if (other.maxX > this.minX && other.minX < this.maxX && other.maxY > this.minY && other.minY < this.maxY) {
-      if (offsetZ > 0.0 && other.maxZ <= this.minZ) {
+    if (other.maxX - this.minX > EPSILON && this.maxX - other.minX > EPSILON && other.maxY - this.minY > EPSILON && this.maxY - other.minY > EPSILON) {
+      if (offsetZ > 0.0 && other.maxZ <= this.minZ + EPSILON) {
         offsetZ = Math.min(this.minZ - other.maxZ, offsetZ)
-      } else if (offsetZ < 0.0 && other.minZ >= this.maxZ) {
+      } else if (offsetZ < 0.0 && other.minZ >= this.maxZ - EPSILON) {
         offsetZ = Math.max(this.maxZ - other.minZ, offsetZ)
       }
     }
